// GENERATED CODE - DO NOT MODIFY BY HAND

part of 'subject_entity.dart';

// **************************************************************************
// CopyWithGenerator
// **************************************************************************

abstract class _$SubjectEntityCWProxy {
  SubjectEntity subject(Subject subject);

  SubjectEntity delta(dynamic delta);

  SubjectEntity rank(dynamic rank);

  /// This function **does support** nullification of nullable fields. All `null` values passed to `non-nullable` fields will be ignored. You can also use `SubjectEntity(...).copyWith.fieldName(...)` to override fields one at a time with nullification support.
  ///
  /// Usage
  /// ```dart
  /// SubjectEntity(...).copyWith(id: 12, name: "My name")
  /// ````
  SubjectEntity call({
    Subject? subject,
    dynamic delta,
    dynamic rank,
  });
}

/// Proxy class for `copyWith` functionality. This is a callable class and can be used as follows: `instanceOfSubjectEntity.copyWith(...)`. Additionally contains functions for specific fields e.g. `instanceOfSubjectEntity.copyWith.fieldName(...)`
class _$SubjectEntityCWProxyImpl implements _$SubjectEntityCWProxy {
  const _$SubjectEntityCWProxyImpl(this._value);

  final SubjectEntity _value;

  @override
  SubjectEntity subject(Subject subject) => this(subject: subject);

  @override
  SubjectEntity delta(dynamic delta) => this(delta: delta);

  @override
  SubjectEntity rank(dynamic rank) => this(rank: rank);

  @override

  /// This function **does support** nullification of nullable fields. All `null` values passed to `non-nullable` fields will be ignored. You can also use `SubjectEntity(...).copyWith.fieldName(...)` to override fields one at a time with nullification support.
  ///
  /// Usage
  /// ```dart
  /// SubjectEntity(...).copyWith(id: 12, name: "My name")
  /// ````
  SubjectEntity call({
    Object? subject = const $CopyWithPlaceholder(),
    Object? delta = const $CopyWithPlaceholder(),
    Object? rank = const $CopyWithPlaceholder(),
  }) {
    return SubjectEntity(
      subject: subject == const $CopyWithPlaceholder() || subject == null
          ? _value.subject
          // ignore: cast_nullable_to_non_nullable
          : subject as Subject,
      delta: delta == const $CopyWithPlaceholder() || delta == null
          ? _value.delta
          // ignore: cast_nullable_to_non_nullable
          : delta as dynamic,
      rank: rank == const $CopyWithPlaceholder() || rank == null
          ? _value.rank
          // ignore: cast_nullable_to_non_nullable
          : rank as dynamic,
    );
  }
}

extension $SubjectEntityCopyWith on SubjectEntity {
  /// Returns a callable class that can be used as follows: `instanceOfSubjectEntity.copyWith(...)` or like so:`instanceOfSubjectEntity.copyWith.fieldName(...)`.
  // ignore: library_private_types_in_public_api
  _$SubjectEntityCWProxy get copyWith => _$SubjectEntityCWProxyImpl(this);
}

abstract class _$SubjectCWProxy {
  Subject durations(dynamic durations);

  Subject collect_count(dynamic collect_count);

  Subject mainland_pubdate(dynamic mainland_pubdate);

  Subject has_video(dynamic has_video);

  Subject original_title(dynamic original_title);

  Subject subtype(dynamic subtype);

  Subject directors(dynamic directors);

  Subject pubdates(dynamic pubdates);

  Subject casts(List<Cast> casts);

  Subject year(dynamic year);

  Subject alt(dynamic alt);

  Subject id(dynamic id);

  Subject images(Images images);

  Subject tag(bool tag);

  Subject rating(Rating rating);

  Subject genres(dynamic genres);

  Subject title(dynamic title);

  /// This function **does support** nullification of nullable fields. All `null` values passed to `non-nullable` fields will be ignored. You can also use `Subject(...).copyWith.fieldName(...)` to override fields one at a time with nullification support.
  ///
  /// Usage
  /// ```dart
  /// Subject(...).copyWith(id: 12, name: "My name")
  /// ````
  Subject call({
    dynamic durations,
    dynamic collect_count,
    dynamic mainland_pubdate,
    dynamic has_video,
    dynamic original_title,
    dynamic subtype,
    dynamic directors,
    dynamic pubdates,
    List<Cast>? casts,
    dynamic year,
    dynamic alt,
    dynamic id,
    Images? images,
    bool? tag,
    Rating? rating,
    dynamic genres,
    dynamic title,
  });
}

/// Proxy class for `copyWith` functionality. This is a callable class and can be used as follows: `instanceOfSubject.copyWith(...)`. Additionally contains functions for specific fields e.g. `instanceOfSubject.copyWith.fieldName(...)`
class _$SubjectCWProxyImpl implements _$SubjectCWProxy {
  const _$SubjectCWProxyImpl(this._value);

  final Subject _value;

  @override
  Subject durations(dynamic durations) => this(durations: durations);

  @override
  Subject collect_count(dynamic collect_count) =>
      this(collect_count: collect_count);

  @override
  Subject mainland_pubdate(dynamic mainland_pubdate) =>
      this(mainland_pubdate: mainland_pubdate);

  @override
  Subject has_video(dynamic has_video) => this(has_video: has_video);

  @override
  Subject original_title(dynamic original_title) =>
      this(original_title: original_title);

  @override
  Subject subtype(dynamic subtype) => this(subtype: subtype);

  @override
  Subject directors(dynamic directors) => this(directors: directors);

  @override
  Subject pubdates(dynamic pubdates) => this(pubdates: pubdates);

  @override
  Subject casts(List<Cast> casts) => this(casts: casts);

  @override
  Subject year(dynamic year) => this(year: year);

  @override
  Subject alt(dynamic alt) => this(alt: alt);

  @override
  Subject id(dynamic id) => this(id: id);

  @override
  Subject images(Images images) => this(images: images);

  @override
  Subject tag(bool tag) => this(tag: tag);

  @override
  Subject rating(Rating rating) => this(rating: rating);

  @override
  Subject genres(dynamic genres) => this(genres: genres);

  @override
  Subject title(dynamic title) => this(title: title);

  @override

  /// This function **does support** nullification of nullable fields. All `null` values passed to `non-nullable` fields will be ignored. You can also use `Subject(...).copyWith.fieldName(...)` to override fields one at a time with nullification support.
  ///
  /// Usage
  /// ```dart
  /// Subject(...).copyWith(id: 12, name: "My name")
  /// ````
  Subject call({
    Object? durations = const $CopyWithPlaceholder(),
    Object? collect_count = const $CopyWithPlaceholder(),
    Object? mainland_pubdate = const $CopyWithPlaceholder(),
    Object? has_video = const $CopyWithPlaceholder(),
    Object? original_title = const $CopyWithPlaceholder(),
    Object? subtype = const $CopyWithPlaceholder(),
    Object? directors = const $CopyWithPlaceholder(),
    Object? pubdates = const $CopyWithPlaceholder(),
    Object? casts = const $CopyWithPlaceholder(),
    Object? year = const $CopyWithPlaceholder(),
    Object? alt = const $CopyWithPlaceholder(),
    Object? id = const $CopyWithPlaceholder(),
    Object? images = const $CopyWithPlaceholder(),
    Object? tag = const $CopyWithPlaceholder(),
    Object? rating = const $CopyWithPlaceholder(),
    Object? genres = const $CopyWithPlaceholder(),
    Object? title = const $CopyWithPlaceholder(),
  }) {
    return Subject(
      durations: durations == const $CopyWithPlaceholder() || durations == null
          ? _value.durations
          // ignore: cast_nullable_to_non_nullable
          : durations as dynamic,
      collect_count:
          collect_count == const $CopyWithPlaceholder() || collect_count == null
              ? _value.collect_count
              // ignore: cast_nullable_to_non_nullable
              : collect_count as dynamic,
      mainland_pubdate: mainland_pubdate == const $CopyWithPlaceholder() ||
              mainland_pubdate == null
          ? _value.mainland_pubdate
          // ignore: cast_nullable_to_non_nullable
          : mainland_pubdate as dynamic,
      has_video: has_video == const $CopyWithPlaceholder() || has_video == null
          ? _value.has_video
          // ignore: cast_nullable_to_non_nullable
          : has_video as dynamic,
      original_title: original_title == const $CopyWithPlaceholder() ||
              original_title == null
          ? _value.original_title
          // ignore: cast_nullable_to_non_nullable
          : original_title as dynamic,
      subtype: subtype == const $CopyWithPlaceholder() || subtype == null
          ? _value.subtype
          // ignore: cast_nullable_to_non_nullable
          : subtype as dynamic,
      directors: directors == const $CopyWithPlaceholder() || directors == null
          ? _value.directors
          // ignore: cast_nullable_to_non_nullable
          : directors as dynamic,
      pubdates: pubdates == const $CopyWithPlaceholder() || pubdates == null
          ? _value.pubdates
          // ignore: cast_nullable_to_non_nullable
          : pubdates as dynamic,
      casts: casts == const $CopyWithPlaceholder() || casts == null
          ? _value.casts
          // ignore: cast_nullable_to_non_nullable
          : casts as List<Cast>,
      year: year == const $CopyWithPlaceholder() || year == null
          ? _value.year
          // ignore: cast_nullable_to_non_nullable
          : year as dynamic,
      alt: alt == const $CopyWithPlaceholder() || alt == null
          ? _value.alt
          // ignore: cast_nullable_to_non_nullable
          : alt as dynamic,
      id: id == const $CopyWithPlaceholder() || id == null
          ? _value.id
          // ignore: cast_nullable_to_non_nullable
          : id as dynamic,
      images: images == const $CopyWithPlaceholder() || images == null
          ? _value.images
          // ignore: cast_nullable_to_non_nullable
          : images as Images,
      tag: tag == const $CopyWithPlaceholder() || tag == null
          ? _value.tag
          // ignore: cast_nullable_to_non_nullable
          : tag as bool,
      rating: rating == const $CopyWithPlaceholder() || rating == null
          ? _value.rating
          // ignore: cast_nullable_to_non_nullable
          : rating as Rating,
      genres: genres == const $CopyWithPlaceholder() || genres == null
          ? _value.genres
          // ignore: cast_nullable_to_non_nullable
          : genres as dynamic,
      title: title == const $CopyWithPlaceholder() || title == null
          ? _value.title
          // ignore: cast_nullable_to_non_nullable
          : title as dynamic,
    );
  }
}

extension $SubjectCopyWith on Subject {
  /// Returns a callable class that can be used as follows: `instanceOfSubject.copyWith(...)` or like so:`instanceOfSubject.copyWith.fieldName(...)`.
  // ignore: library_private_types_in_public_api
  _$SubjectCWProxy get copyWith => _$SubjectCWProxyImpl(this);
}

abstract class _$ImagesCWProxy {
  Images small(dynamic small);

  Images large(dynamic large);

  Images medium(dynamic medium);

  /// This function **does support** nullification of nullable fields. All `null` values passed to `non-nullable` fields will be ignored. You can also use `Images(...).copyWith.fieldName(...)` to override fields one at a time with nullification support.
  ///
  /// Usage
  /// ```dart
  /// Images(...).copyWith(id: 12, name: "My name")
  /// ````
  Images call({
    dynamic small,
    dynamic large,
    dynamic medium,
  });
}

/// Proxy class for `copyWith` functionality. This is a callable class and can be used as follows: `instanceOfImages.copyWith(...)`. Additionally contains functions for specific fields e.g. `instanceOfImages.copyWith.fieldName(...)`
class _$ImagesCWProxyImpl implements _$ImagesCWProxy {
  const _$ImagesCWProxyImpl(this._value);

  final Images _value;

  @override
  Images small(dynamic small) => this(small: small);

  @override
  Images large(dynamic large) => this(large: large);

  @override
  Images medium(dynamic medium) => this(medium: medium);

  @override

  /// This function **does support** nullification of nullable fields. All `null` values passed to `non-nullable` fields will be ignored. You can also use `Images(...).copyWith.fieldName(...)` to override fields one at a time with nullification support.
  ///
  /// Usage
  /// ```dart
  /// Images(...).copyWith(id: 12, name: "My name")
  /// ````
  Images call({
    Object? small = const $CopyWithPlaceholder(),
    Object? large = const $CopyWithPlaceholder(),
    Object? medium = const $CopyWithPlaceholder(),
  }) {
    return Images(
      small: small == const $CopyWithPlaceholder() || small == null
          ? _value.small
          // ignore: cast_nullable_to_non_nullable
          : small as dynamic,
      large: large == const $CopyWithPlaceholder() || large == null
          ? _value.large
          // ignore: cast_nullable_to_non_nullable
          : large as dynamic,
      medium: medium == const $CopyWithPlaceholder() || medium == null
          ? _value.medium
          // ignore: cast_nullable_to_non_nullable
          : medium as dynamic,
    );
  }
}

extension $ImagesCopyWith on Images {
  /// Returns a callable class that can be used as follows: `instanceOfImages.copyWith(...)` or like so:`instanceOfImages.copyWith.fieldName(...)`.
  // ignore: library_private_types_in_public_api
  _$ImagesCWProxy get copyWith => _$ImagesCWProxyImpl(this);
}

abstract class _$RatingCWProxy {
  Rating average(dynamic average);

  Rating max(dynamic max);

  /// This function **does support** nullification of nullable fields. All `null` values passed to `non-nullable` fields will be ignored. You can also use `Rating(...).copyWith.fieldName(...)` to override fields one at a time with nullification support.
  ///
  /// Usage
  /// ```dart
  /// Rating(...).copyWith(id: 12, name: "My name")
  /// ````
  Rating call({
    dynamic average,
    dynamic max,
  });
}

/// Proxy class for `copyWith` functionality. This is a callable class and can be used as follows: `instanceOfRating.copyWith(...)`. Additionally contains functions for specific fields e.g. `instanceOfRating.copyWith.fieldName(...)`
class _$RatingCWProxyImpl implements _$RatingCWProxy {
  const _$RatingCWProxyImpl(this._value);

  final Rating _value;

  @override
  Rating average(dynamic average) => this(average: average);

  @override
  Rating max(dynamic max) => this(max: max);

  @override

  /// This function **does support** nullification of nullable fields. All `null` values passed to `non-nullable` fields will be ignored. You can also use `Rating(...).copyWith.fieldName(...)` to override fields one at a time with nullification support.
  ///
  /// Usage
  /// ```dart
  /// Rating(...).copyWith(id: 12, name: "My name")
  /// ````
  Rating call({
    Object? average = const $CopyWithPlaceholder(),
    Object? max = const $CopyWithPlaceholder(),
  }) {
    return Rating(
      average: average == const $CopyWithPlaceholder() || average == null
          ? _value.average
          // ignore: cast_nullable_to_non_nullable
          : average as dynamic,
      max: max == const $CopyWithPlaceholder() || max == null
          ? _value.max
          // ignore: cast_nullable_to_non_nullable
          : max as dynamic,
    );
  }
}

extension $RatingCopyWith on Rating {
  /// Returns a callable class that can be used as follows: `instanceOfRating.copyWith(...)` or like so:`instanceOfRating.copyWith.fieldName(...)`.
  // ignore: library_private_types_in_public_api
  _$RatingCWProxy get copyWith => _$RatingCWProxyImpl(this);
}

abstract class _$CastCWProxy {
  Cast avatars(Avatar avatars);

  Cast name_en(dynamic name_en);

  Cast name(dynamic name);

  Cast alt(dynamic alt);

  Cast id(dynamic id);

  /// This function **does support** nullification of nullable fields. All `null` values passed to `non-nullable` fields will be ignored. You can also use `Cast(...).copyWith.fieldName(...)` to override fields one at a time with nullification support.
  ///
  /// Usage
  /// ```dart
  /// Cast(...).copyWith(id: 12, name: "My name")
  /// ````
  Cast call({
    Avatar? avatars,
    dynamic name_en,
    dynamic name,
    dynamic alt,
    dynamic id,
  });
}

/// Proxy class for `copyWith` functionality. This is a callable class and can be used as follows: `instanceOfCast.copyWith(...)`. Additionally contains functions for specific fields e.g. `instanceOfCast.copyWith.fieldName(...)`
class _$CastCWProxyImpl implements _$CastCWProxy {
  const _$CastCWProxyImpl(this._value);

  final Cast _value;

  @override
  Cast avatars(Avatar avatars) => this(avatars: avatars);

  @override
  Cast name_en(dynamic name_en) => this(name_en: name_en);

  @override
  Cast name(dynamic name) => this(name: name);

  @override
  Cast alt(dynamic alt) => this(alt: alt);

  @override
  Cast id(dynamic id) => this(id: id);

  @override

  /// This function **does support** nullification of nullable fields. All `null` values passed to `non-nullable` fields will be ignored. You can also use `Cast(...).copyWith.fieldName(...)` to override fields one at a time with nullification support.
  ///
  /// Usage
  /// ```dart
  /// Cast(...).copyWith(id: 12, name: "My name")
  /// ````
  Cast call({
    Object? avatars = const $CopyWithPlaceholder(),
    Object? name_en = const $CopyWithPlaceholder(),
    Object? name = const $CopyWithPlaceholder(),
    Object? alt = const $CopyWithPlaceholder(),
    Object? id = const $CopyWithPlaceholder(),
  }) {
    return Cast(
      avatars == const $CopyWithPlaceholder() || avatars == null
          ? _value.avatars
          // ignore: cast_nullable_to_non_nullable
          : avatars as Avatar,
      name_en == const $CopyWithPlaceholder() || name_en == null
          ? _value.name_en
          // ignore: cast_nullable_to_non_nullable
          : name_en as dynamic,
      name == const $CopyWithPlaceholder() || name == null
          ? _value.name
          // ignore: cast_nullable_to_non_nullable
          : name as dynamic,
      alt == const $CopyWithPlaceholder() || alt == null
          ? _value.alt
          // ignore: cast_nullable_to_non_nullable
          : alt as dynamic,
      id == const $CopyWithPlaceholder() || id == null
          ? _value.id
          // ignore: cast_nullable_to_non_nullable
          : id as dynamic,
    );
  }
}

extension $CastCopyWith on Cast {
  /// Returns a callable class that can be used as follows: `instanceOfCast.copyWith(...)` or like so:`instanceOfCast.copyWith.fieldName(...)`.
  // ignore: library_private_types_in_public_api
  _$CastCWProxy get copyWith => _$CastCWProxyImpl(this);
}

abstract class _$AvatarCWProxy {
  Avatar small(dynamic small);

  Avatar large(dynamic large);

  Avatar medium(dynamic medium);

  /// This function **does support** nullification of nullable fields. All `null` values passed to `non-nullable` fields will be ignored. You can also use `Avatar(...).copyWith.fieldName(...)` to override fields one at a time with nullification support.
  ///
  /// Usage
  /// ```dart
  /// Avatar(...).copyWith(id: 12, name: "My name")
  /// ````
  Avatar call({
    dynamic small,
    dynamic large,
    dynamic medium,
  });
}

/// Proxy class for `copyWith` functionality. This is a callable class and can be used as follows: `instanceOfAvatar.copyWith(...)`. Additionally contains functions for specific fields e.g. `instanceOfAvatar.copyWith.fieldName(...)`
class _$AvatarCWProxyImpl implements _$AvatarCWProxy {
  const _$AvatarCWProxyImpl(this._value);

  final Avatar _value;

  @override
  Avatar small(dynamic small) => this(small: small);

  @override
  Avatar large(dynamic large) => this(large: large);

  @override
  Avatar medium(dynamic medium) => this(medium: medium);

  @override

  /// This function **does support** nullification of nullable fields. All `null` values passed to `non-nullable` fields will be ignored. You can also use `Avatar(...).copyWith.fieldName(...)` to override fields one at a time with nullification support.
  ///
  /// Usage
  /// ```dart
  /// Avatar(...).copyWith(id: 12, name: "My name")
  /// ````
  Avatar call({
    Object? small = const $CopyWithPlaceholder(),
    Object? large = const $CopyWithPlaceholder(),
    Object? medium = const $CopyWithPlaceholder(),
  }) {
    return Avatar(
      small == const $CopyWithPlaceholder() || small == null
          ? _value.small
          // ignore: cast_nullable_to_non_nullable
          : small as dynamic,
      large == const $CopyWithPlaceholder() || large == null
          ? _value.large
          // ignore: cast_nullable_to_non_nullable
          : large as dynamic,
      medium == const $CopyWithPlaceholder() || medium == null
          ? _value.medium
          // ignore: cast_nullable_to_non_nullable
          : medium as dynamic,
    );
  }
}

extension $AvatarCopyWith on Avatar {
  /// Returns a callable class that can be used as follows: `instanceOfAvatar.copyWith(...)` or like so:`instanceOfAvatar.copyWith.fieldName(...)`.
  // ignore: library_private_types_in_public_api
  _$AvatarCWProxy get copyWith => _$AvatarCWProxyImpl(this);
}

// **************************************************************************
// JsonSerializableGenerator
// **************************************************************************

SubjectEntity _$SubjectEntityFromJson(Map<String, dynamic> json) =>
    SubjectEntity(
      subject: json['subject'] == null
          ? const Subject()
          : Subject.fromJson(json['subject'] as Map<String, dynamic>),
      delta: json['delta'],
      rank: json['rank'],
    );

Map<String, dynamic> _$SubjectEntityToJson(SubjectEntity instance) =>
    <String, dynamic>{
      'subject': instance.subject,
      'rank': instance.rank,
      'delta': instance.delta,
    };

Subject _$SubjectFromJson(Map<String, dynamic> json) => Subject(
      durations: json['durations'] ?? const [],
      collect_count: json['collect_count'] ?? 0,
      mainland_pubdate: json['mainland_pubdate'] ?? '',
      has_video: json['has_video'] ?? false,
      original_title: json['original_title'] ?? '',
      subtype: json['subtype'] ?? '',
      directors: json['directors'] ?? const [],
      pubdates: json['pubdates'] ?? const [],
      casts: (json['casts'] as List<dynamic>?)
              ?.map((e) => Cast.fromJson(e as Map<String, dynamic>))
              .toList() ??
          const [],
      year: json['year'] ?? '',
      alt: json['alt'] ?? '',
      id: json['id'] ?? '',
      images: json['images'] == null
          ? const Images()
          : Images.fromJson(json['images'] as Map<String, dynamic>),
      tag: json['tag'] as bool? ?? false,
      rating: json['rating'] == null
          ? const Rating()
          : Rating.fromJson(json['rating'] as Map<String, dynamic>),
      genres: json['genres'] ?? const [],
      title: json['title'] ?? '',
    );

Map<String, dynamic> _$SubjectToJson(Subject instance) => <String, dynamic>{
      'tag': instance.tag,
      'rating': instance.rating,
      'genres': instance.genres,
      'title': instance.title,
      'casts': instance.casts,
      'durations': instance.durations,
      'collect_count': instance.collect_count,
      'mainland_pubdate': instance.mainland_pubdate,
      'has_video': instance.has_video,
      'original_title': instance.original_title,
      'subtype': instance.subtype,
      'directors': instance.directors,
      'pubdates': instance.pubdates,
      'year': instance.year,
      'images': instance.images,
      'alt': instance.alt,
      'id': instance.id,
    };

Images _$ImagesFromJson(Map<String, dynamic> json) => Images(
      small: json['small'],
      large: json['large'],
      medium: json['medium'],
    );

Map<String, dynamic> _$ImagesToJson(Images instance) => <String, dynamic>{
      'small': instance.small,
      'large': instance.large,
      'medium': instance.medium,
    };

Rating _$RatingFromJson(Map<String, dynamic> json) => Rating(
      average: json['average'],
      max: json['max'],
    );

Map<String, dynamic> _$RatingToJson(Rating instance) => <String, dynamic>{
      'average': instance.average,
      'max': instance.max,
    };

Cast _$CastFromJson(Map<String, dynamic> json) => Cast(
      Avatar.fromJson(json['avatars'] as Map<String, dynamic>),
      json['name_en'],
      json['name'],
      json['alt'],
      json['id'],
    );

Map<String, dynamic> _$CastToJson(Cast instance) => <String, dynamic>{
      'id': instance.id,
      'name_en': instance.name_en,
      'name': instance.name,
      'avatars': instance.avatars,
      'alt': instance.alt,
    };

Avatar _$AvatarFromJson(Map<String, dynamic> json) => Avatar(
      json['small'],
      json['large'],
      json['medium'],
    );

Map<String, dynamic> _$AvatarToJson(Avatar instance) => <String, dynamic>{
      'medium': instance.medium,
      'large': instance.large,
      'small': instance.small,
    };
